<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Cinética Química</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.2.1/lib/browser/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 20px;
            max-width: 95%;
            margin: 0 auto;
        }
        .left-panel, .right-panel {
            background-color: white;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            flex: 1 1 320px;
        }
        .left-panel {
            max-width: 420px;
        }
        .right-panel {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        input, select, button {
            margin: 5px 0;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: calc(100% - 20px);
        }
        input[type="checkbox"] {
            width: auto;
            margin-left: 0;
        }
        label {
            font-weight: bold;
            margin-top: 10px;
            display: inline-block;
        }
        .form-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .form-group label {
            flex: 1;
            margin-right: 10px;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table th, .species-table td {
            border: 1px solid #ccc;
            padding: 6px;
            text-align: center;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table input[type="number"] {
            width: 100%;
            box-sizing: border-box;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .status-line {
            font-size: 0.95rem;
            margin-top: 15px;
            font-weight: bold;
            color: #0a3d62;
        }
        .form-group input, .form-group select {
            flex: 2;
        }
        button {
            background-color: #005fcc;
            color: #ffffff;
            cursor: pointer;
            border: none;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #004099;
        }
        input:focus, select:focus, button:focus {
            outline: 3px solid #ffbf47;
            outline-offset: 2px;
        }
        canvas {
            width: 100%;
            height: 600px; /* Aumentar la altura de la gráfica */
        }
        sub {
            vertical-align: sub;
            font-size: smaller;
        }
        .advanced-settings {
            margin-top: 15px;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .button-group button {
            flex: 1 1 150px;
        }
        .helper-text {
            font-size: 0.9rem;
            color: #1a1a1a;
            margin-top: 10px;
        }
        @media (max-width: 900px) {
            .container {
                justify-content: center;
            }
            .left-panel, .right-panel {
                max-width: 100%;
            }
            canvas {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container" role="main" aria-labelledby="appTitle">
        <!-- Panel Izquierdo: Formulario -->
        <div class="left-panel" role="form" aria-describedby="keyboardInstructions">
            <h1 id="appTitle">Simulador de Cinética Química</h1>

            <div class="form-group">
                <label for="numReactivos">Número de reactivos:</label>
                <input type="number" id="numReactivos" value="1" min="1" onchange="actualizarFormulario()">
            </div>

            <div id="reactivosForm" aria-live="polite"></div>

            <div class="form-group">
                <label for="k">Constante de velocidad (k):</label>
                <input type="number" id="k" value="0.6" step="0.01">
            </div>

            <div class="form-group">
                <label for="unidadVelocidad">Unidad de constante de velocidad:</label>
                <select id="unidadVelocidad">
                    <option value="s">1/segundos</option>
                    <option value="min">1/minutos</option>
                    <option value="h">1/horas</option>
                </select>
            </div>

            <div class="form-group">
                <label for="tiempoFinal">Tiempo final (<i>t<sub>f</sub></i>):</label>
                <input type="number" id="tiempoFinal" value="10" step="1">
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="tiempoAutomatico">
                    Calcular automáticamente el tiempo de reacción
                </label>
            </div>

            <div class="form-group">
                <label for="unidadTiempo">Unidad de tiempo de reacción:</label>
                <select id="unidadTiempo">
                    <option value="s">segundos</option>
                    <option value="min">minutos</option>
                    <option value="h">horas</option>
                </select>
            </div>

            <div class="form-group">
                <label for="unidadConcentracion">Unidad de concentración:</label>
                <select id="unidadConcentracion">
                    <option value="M">Molar</option>
                    <option value="mM">mMolar</option>
                    <option value="uM">µMolar</option>
                </select>
            </div>

            <div class="form-group">
                <label for="reactivoBase">Especie para representar:</label>
                <select id="reactivoBase"></select>
            </div>

            <div class="form-group button-group" role="group" aria-label="Acciones del simulador">
                <button onclick="simular()">Resolver y Representar</button>
                <button onclick="limpiar()">Borrar Resultado</button>
                <button onclick="descargarCSV()">Descargar CSV</button>
            </div>

            <p class="helper-text" id="keyboardInstructions">Usa la tecla Tab para navegar entre los controles y Enter o la barra espaciadora para activar los botones.</p>
            <!-- === Isolation & limiting-reactant stop rule === -->
            <p id="limitingStatus" class="status-line" aria-live="polite"></p>

            <div class="form-group">
                <label for="notacionDecimal">Notación decimal:</label>
                <select id="notacionDecimal">
                    <option value="punto">Punto decimal</option>
                    <option value="coma">Coma decimal</option>
                </select>
            </div>

            <details class="advanced-settings">
                <summary>Configuración avanzada</summary>
                <div class="form-group">
                    <label for="metodoIntegracion">Método numérico:</label>
                    <select id="metodoIntegracion">
                        <option value="rk4" selected>Runge-Kutta 4º orden</option>
                        <option value="euler">Euler hacia adelante</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="numPuntos">Puntos de cálculo:</label>
                    <input type="number" id="numPuntos" value="200" min="10" step="10">
                </div>
                <div class="form-group">
                    <label for="forzarNoNegativas">Forzar concentraciones no negativas:</label>
                    <input type="checkbox" id="forzarNoNegativas" checked>
                </div>
                <!-- === Isolation & limiting-reactant stop rule === -->
                <div class="form-group">
                    <label for="salvaguardaDerivada">Detener si |dC<sub>lim</sub>/dt| ≤ 1e-12:</label>
                    <input type="checkbox" id="salvaguardaDerivada">
                </div>
            </details>
        </div>

        <!-- Panel Derecho: Gráfica -->
        <div class="right-panel" role="region" aria-label="Gráfico de resultados">
            <canvas id="grafica"></canvas>
        </div>
    </div>

    <script>
        let grafica;  // Variable para la gráfica
        let resultados = [];  // Almacenar resultados para CSV

        // === Isolation & limiting-reactant stop rule ===
        function getCheckedIsolationSet() {
            const set = new Set();
            document.querySelectorAll('.cbIsolation').forEach((checkbox) => {
                if (checkbox.checked) {
                    const idx = parseInt(checkbox.dataset.idx, 10);
                    if (!Number.isNaN(idx)) {
                        set.add(idx);
                    }
                }
            });
            return set;
        }

        // === Catalyst feature ===
        function getCatalystSet() {
            const set = new Set();
            document.querySelectorAll('.cbCatalyst').forEach((checkbox) => {
                if (checkbox.checked) {
                    const idx = parseInt(checkbox.dataset.idx, 10);
                    if (!Number.isNaN(idx)) {
                        set.add(idx);
                    }
                }
            });
            return set;
        }

        // === Isolation & limiting-reactant stop rule ===
        function obtenerParametrosReactivos() {
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10) || 0;
            const concentraciones = [];
            const coeficientes = [];

            for (let i = 0; i < numReactivos; i++) {
                const conc = parseFloat(document.getElementById(`C0${i}`)?.value);
                const coef = parseFloat(document.getElementById(`stoich${i}`)?.value);
                concentraciones.push(Number.isNaN(conc) ? 0 : conc);
                coeficientes.push(Number.isNaN(coef) ? 0 : coef);
            }

            return { concentraciones, coeficientes };
        }

        // === Isolation & limiting-reactant stop rule ===
        function validateIsolation(coeficientes, concentraciones, isolationSet) {
            const mensajes = [];
            const validado = new Set(isolationSet);
            const reactantes = [];
            const razones = new Map();

            coeficientes.forEach((coef, idx) => {
                if (coef < 0) {
                    const absCoef = Math.abs(coef);
                    const conc = Math.max(concentraciones[idx] || 0, 0);
                    const ratio = absCoef > 0 ? conc / absCoef : Infinity;
                    reactantes.push(idx);
                    razones.set(idx, ratio);
                }
            });

            if (reactantes.length === 0) {
                return { validatedSet: validado, mensajes };
            }

            const noAislados = reactantes.filter(idx => !validado.has(idx));

            if (noAislados.length === 0 && validado.size > 0) {
                let mejor = null;
                validado.forEach((idx) => {
                    if (!razones.has(idx)) {
                        return;
                    }
                    const ratio = razones.get(idx);
                    if (!mejor || ratio > mejor.ratio) {
                        mejor = { idx, ratio };
                    }
                });
                validado.forEach((idx) => {
                    if (!mejor || idx === mejor.idx) {
                        return;
                    }
                    validado.delete(idx);
                });
                if (mejor && validado.size === reactantes.length) {
                    validado.delete(mejor.idx);
                    mensajes.push('No es posible aislar todos los reactivos. Se desmarcaron todas las especies para mantener al menos un reactivo no aislado.');
                } else if (mejor) {
                    mensajes.push(`No es posible aislar todos los reactivos. Solo se mantiene aislada la Especie ${mejor.idx + 1}.`);
                } else {
                    mensajes.push('No es posible aislar todos los reactivos. Se desmarcaron las selecciones.');
                    validado.clear();
                }
                return { validatedSet: validado, mensajes };
            }

            if (noAislados.length > 0) {
                const Rmin = Math.min(...noAislados.map(idx => razones.get(idx) ?? Infinity));
                const especiesInvalidas = [];
                validado.forEach((idx) => {
                    if (!razones.has(idx)) {
                        return;
                    }
                    const ratio = razones.get(idx);
                    if (ratio < 10 * Rmin) {
                        validado.delete(idx);
                        especiesInvalidas.push(`Especie ${idx + 1}`);
                    }
                });
                if (especiesInvalidas.length > 0) {
                    mensajes.push(`Las siguientes especies no cumplen la condición 10:1 y fueron desmarcadas: ${especiesInvalidas.join(', ')}. Se requiere R_i ≥ 10 × R_min.`);
                }
            }

            return { validatedSet: validado, mensajes };
        }

        // === Isolation & limiting-reactant stop rule ===
        function buildIsolationSetValidated(coeficientes, concentraciones, opciones = {}) {
            const aislamientoActual = getCheckedIsolationSet();
            const { validatedSet, mensajes } = validateIsolation(coeficientes, concentraciones, aislamientoActual);

            document.querySelectorAll('.cbIsolation').forEach((checkbox) => {
                const idx = parseInt(checkbox.dataset.idx, 10);
                checkbox.checked = validatedSet.has(idx);
            });

            if (mensajes.length > 0 && !opciones.silencioso) {
                alert(mensajes.join('\n'));
            }

            return validatedSet;
        }

        // === Isolation & limiting-reactant stop rule ===
        function manejarCambioIsolation(opciones = {}) {
            const { concentraciones, coeficientes } = obtenerParametrosReactivos();
            buildIsolationSetValidated(coeficientes, concentraciones, opciones);
        }

        // === Catalyst feature ===
        function manejarCambioIsolationCheckbox(evento) {
            const checkbox = evento.target;
            if (!checkbox) return;
            if (checkbox.checked) {
                const idx = parseInt(checkbox.dataset.idx, 10);
                const catalystCheckbox = document.querySelector(`.cbCatalyst[data-idx="${idx}"]`);
                if (catalystCheckbox && catalystCheckbox.checked) {
                    checkbox.checked = false;
                    alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
                }
            }
            manejarCambioIsolation();
        }

        // === Catalyst feature ===
        function manejarCambioCatalystCheckbox(evento) {
            const checkbox = evento.target;
            if (!checkbox) return;
            if (checkbox.checked) {
                const idx = parseInt(checkbox.dataset.idx, 10);
                const isolationCheckbox = document.querySelector(`.cbIsolation[data-idx="${idx}"]`);
                if (isolationCheckbox && isolationCheckbox.checked) {
                    isolationCheckbox.checked = false;
                    alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
                }
            }
            manejarCambioIsolation();
        }

        // Actualiza el formulario según el número de reactivos
        function actualizarFormulario() {
            // === Isolation & limiting-reactant stop rule ===
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10) || 0;
            const reactivosForm = document.getElementById('reactivosForm');
            const reactivoBaseSelect = document.getElementById('reactivoBase');
            reactivosForm.innerHTML = '';
            reactivoBaseSelect.innerHTML = '';

            const tabla = document.createElement('table');
            tabla.className = 'species-table';

            const thead = document.createElement('thead');
            thead.innerHTML = '<tr><th>Especie</th><th>Orden</th><th>[A]<sub>0</sub></th><th>ν</th><th>Isolation</th><th>Catalyst</th></tr>'; // === Catalyst feature ===
            tabla.appendChild(thead);

            const tbody = document.createElement('tbody');

            for (let i = 0; i < numReactivos; i++) {
                const fila = document.createElement('tr');

                const celdaNombre = document.createElement('td');
                celdaNombre.textContent = `Especie ${i + 1}`;
                fila.appendChild(celdaNombre);

                const celdaOrden = document.createElement('td');
                const inputOrden = document.createElement('input');
                inputOrden.type = 'number';
                inputOrden.id = `orden${i}`;
                inputOrden.value = '1';
                inputOrden.step = '0.1';
                inputOrden.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaOrden.appendChild(inputOrden);
                fila.appendChild(celdaOrden);

                const celdaConcentracion = document.createElement('td');
                const inputConcentracion = document.createElement('input');
                inputConcentracion.type = 'number';
                inputConcentracion.id = `C0${i}`;
                inputConcentracion.value = '1';
                inputConcentracion.step = '0.1';
                inputConcentracion.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaConcentracion.appendChild(inputConcentracion);
                fila.appendChild(celdaConcentracion);

                const celdaStoich = document.createElement('td');
                const inputStoich = document.createElement('input');
                inputStoich.type = 'number';
                inputStoich.id = `stoich${i}`;
                inputStoich.value = '-1';
                inputStoich.step = '0.1';
                inputStoich.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaStoich.appendChild(inputStoich);
                fila.appendChild(celdaStoich);

                const celdaIsolation = document.createElement('td');
                const checkboxIsolation = document.createElement('input');
                checkboxIsolation.type = 'checkbox';
                checkboxIsolation.className = 'cbIsolation';
                checkboxIsolation.dataset.idx = i;
                checkboxIsolation.addEventListener('change', manejarCambioIsolationCheckbox); // === Catalyst feature ===
                celdaIsolation.appendChild(checkboxIsolation);
                fila.appendChild(celdaIsolation);

                const celdaCatalyst = document.createElement('td'); // === Catalyst feature ===
                const checkboxCatalyst = document.createElement('input'); // === Catalyst feature ===
                checkboxCatalyst.type = 'checkbox'; // === Catalyst feature ===
                checkboxCatalyst.className = 'cbCatalyst'; // === Catalyst feature ===
                checkboxCatalyst.dataset.idx = i; // === Catalyst feature ===
                checkboxCatalyst.addEventListener('change', manejarCambioCatalystCheckbox); // === Catalyst feature ===
                celdaCatalyst.appendChild(checkboxCatalyst); // === Catalyst feature ===
                fila.appendChild(celdaCatalyst); // === Catalyst feature ===

                tbody.appendChild(fila);

                reactivoBaseSelect.innerHTML += `<option value="${i}">Especie ${i + 1}</option>`;
            }

            tabla.appendChild(tbody);
            reactivosForm.appendChild(tabla);

            manejarCambioIsolation();
        }

        // Función para resolver las ecuaciones y graficar los resultados
        function simular() {
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10);
            const k = parseFloat(document.getElementById('k').value);
            const unidadVelocidad = document.getElementById('unidadVelocidad').value;
            const tiempoFinal = parseFloat(document.getElementById('tiempoFinal').value);
            const unidadTiempo = document.getElementById('unidadTiempo').value;
            const unidadConcentracion = document.getElementById('unidadConcentracion').value;
            const reactivoBase = parseInt(document.getElementById('reactivoBase').value);
            const metodoIntegracion = document.getElementById('metodoIntegracion').value;
            const numPuntos = parseInt(document.getElementById('numPuntos').value, 10);
            const forzarNoNegativas = document.getElementById('forzarNoNegativas').checked;
            const autoTiempo = document.getElementById('tiempoAutomatico').checked;
            const usarSalvaguardaDerivada = document.getElementById('salvaguardaDerivada').checked; // === Isolation & limiting-reactant stop rule ===

            if (isNaN(numPuntos) || numPuntos < 1) {
                alert('El número de puntos de cálculo debe ser un entero positivo.');
                return;
            }

            let ordenes = [];
            let concentracionesIniciales = [];
            let coeficientesEstequiometricos = [];

            for (let i = 0; i < numReactivos; i++) {
                const orden = parseFloat(document.getElementById(`orden${i}`).value);
                const concentracionInicial = parseFloat(document.getElementById(`C0${i}`).value);
                const coeficiente = parseFloat(document.getElementById(`stoich${i}`).value);

                if (isNaN(orden) || isNaN(concentracionInicial) || isNaN(coeficiente)) {
                    alert(`Todos los parámetros del reactivo ${i + 1} deben ser valores numéricos.`);
                    return;
                }

                ordenes.push(orden);
                concentracionesIniciales.push(concentracionInicial);
                coeficientesEstequiometricos.push(coeficiente);
            }

            const C0 = concentracionesIniciales.slice(); // === Catalyst feature ===
            const isolationSet = buildIsolationSetValidated(coeficientesEstequiometricos, concentracionesIniciales); // === Isolation & limiting-reactant stop rule ===
            const catalystSet = getCatalystSet(); // === Catalyst feature ===

            // === Catalyst feature ===
            const indicesSuperpuestos = [];
            isolationSet.forEach((idx) => {
                if (catalystSet.has(idx)) {
                    indicesSuperpuestos.push(idx);
                }
            });
            if (indicesSuperpuestos.length > 0) {
                indicesSuperpuestos.forEach((idx) => {
                    isolationSet.delete(idx);
                    const isolationCheckbox = document.querySelector(`.cbIsolation[data-idx="${idx}"]`);
                    if (isolationCheckbox) {
                        isolationCheckbox.checked = false;
                    }
                });
                alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
            }

            const especiesConstantes = new Set([...isolationSet, ...catalystSet]); // === Catalyst feature ===

            // Conversión de unidades de la constante de velocidad
            let kConvertido = k;
            if (unidadVelocidad === 'min') {
                kConvertido = k / 60;  // Convertir de 1/minutos a 1/segundos
            } else if (unidadVelocidad === 'h') {
                kConvertido = k / 3600;  // Convertir de 1/horas a 1/segundos
            }

            if (!autoTiempo && (isNaN(tiempoFinal) || tiempoFinal <= 0)) {
                alert('El tiempo final debe ser un número positivo.');
                return;
            }

            // Conversión de tiempo de reacción a segundos
            let tiempoFinalSegundos = null;
            if (!autoTiempo) {
                tiempoFinalSegundos = tiempoFinal;
                if (unidadTiempo === 'min') {
                    tiempoFinalSegundos = tiempoFinal * 60;  // Convertir de minutos a segundos
                } else if (unidadTiempo === 'h') {
                    tiempoFinalSegundos = tiempoFinal * 3600;  // Convertir de horas a segundos
                }
            }

            // Resolver ecuaciones diferenciales para cada reactivo usando el método seleccionado
            const pasos = Math.max(numPuntos, 1);
            const dt = autoTiempo || tiempoFinalSegundos === null ? null : tiempoFinalSegundos / pasos;
            let tiempos = [];
            let concentraciones = [];

            const reactivosEstequiometricos = coeficientesEstequiometricos
                .map((coef, idx) => ({ coef, idx }))
                .filter(item => item.coef < 0);

            let reactivosNoAislados = reactivosEstequiometricos.filter(item => !especiesConstantes.has(item.idx)); // === Catalyst feature ===
            if (reactivosNoAislados.length === 0) { // === Catalyst feature ===
                const candidatosCatalyst = reactivosEstequiometricos.filter(item => catalystSet.has(item.idx));
                if (candidatosCatalyst.length > 0) {
                    let mejor = null;
                    candidatosCatalyst.forEach((item) => {
                        const ratio = Math.abs(item.coef) > 0 ? Math.max(C0[item.idx], 0) / Math.abs(item.coef) : -Infinity;
                        if (!mejor || ratio > mejor.ratio) {
                            mejor = { idx: item.idx, ratio };
                        }
                    });
                    if (mejor) {
                        catalystSet.delete(mejor.idx);
                        const catalystCheckbox = document.querySelector(`.cbCatalyst[data-idx="${mejor.idx}"]`);
                        if (catalystCheckbox) {
                            catalystCheckbox.checked = false;
                        }
                        alert('Al menos un reactivo debe permanecer libre. Se desmarcó el catalizador con mayor R_i para continuar.');
                        reactivosNoAislados = reactivosEstequiometricos.filter(item => !isolationSet.has(item.idx) && !catalystSet.has(item.idx));
                        especiesConstantes.clear();
                        isolationSet.forEach(idx => especiesConstantes.add(idx));
                        catalystSet.forEach(idx => especiesConstantes.add(idx));
                    }
                }
            }

            if (reactivosNoAislados.length === 0) { // === Catalyst feature ===
                alert('Debe dejar al menos un reactivo que no sea aislado ni catalizador para continuar con la simulación.');
                return;
            }
            const fraccionRestanteLimitante = 1e-3; // === Isolation & limiting-reactant stop rule ===
            const umbralAbsolutoLimitante = 1e-9; // === Isolation & limiting-reactant stop rule ===

            let infoReactivoLimitante = null;
            if (reactivosNoAislados.length > 0) {
                infoReactivoLimitante = reactivosNoAislados.reduce((limitante, item) => {
                    const coefAbs = Math.abs(item.coef);
                    const concentracionInicial = Math.max(C0[item.idx], 0); // === Catalyst feature ===
                    const ratio = coefAbs > 0 ? concentracionInicial / coefAbs : Infinity;

                    if (!limitante || ratio < limitante.ratio) {
                        return {
                            idx: item.idx,
                            coef: item.coef,
                            ratio,
                            concentracionInicial,
                        };
                    }
                    return limitante;
                }, null);

                if (infoReactivoLimitante) {
                    infoReactivoLimitante.umbralRelativo = infoReactivoLimitante.concentracionInicial * fraccionRestanteLimitante;
                    infoReactivoLimitante.umbralAbsoluto = umbralAbsolutoLimitante;
                    infoReactivoLimitante.fraccionRestante = fraccionRestanteLimitante;
                }
            }

            let conversionLimitante = null;
            let razonDetencion = null; // === Isolation & limiting-reactant stop rule ===

            const calcularDerivadas = (estado) => {
                // === Isolation & limiting-reactant stop rule ===
                const concentracionesEfectivas = estado.map((valor, idx) => {
                    if (isolationSet.has(idx) || catalystSet.has(idx)) { // === Catalyst feature ===
                        return Math.max(C0[idx], 0); // === Catalyst feature ===
                    }
                    return Math.max(valor, 0);
                });
                const producto = concentracionesEfectivas.reduce((acc, C, idx) => acc * Math.pow(C, ordenes[idx]), 1);
                const velocidad = kConvertido * producto;
                return estado.map((_, idx) => {
                    if (especiesConstantes.has(idx)) {
                        return 0;
                    }
                    return coeficientesEstequiometricos[idx] * velocidad;
                });
            };

            const evaluarCriteriosLimite = (estado, derivadasLocales) => {
                // === Isolation & limiting-reactant stop rule ===
                if (!infoReactivoLimitante) {
                    return { detener: false };
                }
                const indice = infoReactivoLimitante.idx;
                const concentracion = Math.max(estado[indice], 0);
                const umbralRelativo = infoReactivoLimitante.umbralRelativo;
                const umbralAbsoluto = infoReactivoLimitante.umbralAbsoluto;
                const derivadaAbs = Math.abs(derivadasLocales[indice] || 0);

                let razon = null;
                if (concentracion <= umbralRelativo) {
                    razon = '99.9% conversion';
                } else if (concentracion <= umbralAbsoluto) {
                    razon = 'Absolute safety floor';
                } else if (usarSalvaguardaDerivada && derivadaAbs <= 1e-12) {
                    razon = 'Derivative safeguard';
                }

                if (!razon) {
                    return { detener: false };
                }

                let conversion = 0;
                if (infoReactivoLimitante.concentracionInicial > 0) {
                    conversion = (1 - (concentracion / infoReactivoLimitante.concentracionInicial)) * 100;
                } else {
                    conversion = concentracion === 0 ? 100 : 0;
                }
                conversion = Math.max(0, Math.min(100, conversion));

                return { detener: true, razon, conversion };
            };

            const aplicarForzado = (estado) => {
                if (!forzarNoNegativas) return estado;
                return estado.map(valor => Math.max(valor, 0));
            };

            let estadoActual = concentracionesIniciales.slice();
            let tiempoActual = 0;

            tiempos.push(tiempoActual);
            concentraciones.push(estadoActual.slice());

            if (autoTiempo) {
                // === Isolation & limiting-reactant stop rule ===
                if (!infoReactivoLimitante) {
                    if (reactivosEstequiometricos.length > 0 && reactivosNoAislados.length === 0) {
                        alert('Todos los reactivos han sido marcados como aislados o catalizadores. Debe dejar al menos un reactivo libre para determinar el reactivo limitante.'); // === Catalyst feature ===
                    } else {
                        alert('Debe definir al menos un reactivo con coeficiente estequiométrico negativo para identificar el reactivo limitante.');
                    }
                    return;
                }

                const indicesReactivos = reactivosEstequiometricos;
                const tolerancia = 1e-8;
                const maxIteraciones = Math.max(pasos * 20, 1000);
                let iteracion = 0;
                let finalizadoAutomaticamente = false;

                let derivadas = calcularDerivadas(estadoActual);
                let evaluacion = evaluarCriteriosLimite(estadoActual, derivadas); // === Isolation & limiting-reactant stop rule ===
                if (evaluacion.detener) {
                    conversionLimitante = evaluacion.conversion;
                    razonDetencion = evaluacion.razon;
                    tiempoFinalSegundos = tiempoActual;
                    finalizadoAutomaticamente = true;
                }

                while (!finalizadoAutomaticamente && iteracion < maxIteraciones) {
                    const tiemposHastaCero = indicesReactivos.map(({ idx }) => {
                        const derivada = derivadas[idx];
                        if (derivada >= 0) return Infinity;
                        const concentracion = Math.max(estadoActual[idx], 0);
                        return concentracion / Math.abs(derivada);
                    });

                    const minimoTiempoHastaCero = Math.min(...tiemposHastaCero);

                    if (!isFinite(minimoTiempoHastaCero) || minimoTiempoHastaCero === Infinity) {
                        break;
                    }

                    // === Robust auto step for n>1 (fractional limiter + dt cap) ===
                    const idxLimitante = infoReactivoLimitante.idx;
                    const concentracionLimitante = Math.max(estadoActual[idxLimitante], 0);
                    const derivadaLimitante = Math.abs(derivadas[idxLimitante]) || 1e-300;
                    const tiempoMinimoLimitante = concentracionLimitante / derivadaLimitante;
                    const eta = 0.01;
                    const pasoFraccional = eta * tiempoMinimoLimitante;
                    const pasoMaximo = 30; // 30 segundos en el sistema interno de integración
                    let pasoAdaptativo = Math.min(tiempoMinimoLimitante / 5, pasoFraccional, pasoMaximo);
                    pasoAdaptativo = Math.max(pasoAdaptativo, tolerancia, 1e-8);

                    let siguienteEstado;
                    if (metodoIntegracion === 'euler') {
                        const k1 = derivadas;
                        siguienteEstado = estadoActual.map((c, idx) => c + k1[idx] * pasoAdaptativo);
                    } else {
                        const k1 = derivadas;
                        const k2 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * pasoAdaptativo * k1[idx]));
                        const k3 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * pasoAdaptativo * k2[idx]));
                        const k4 = calcularDerivadas(estadoActual.map((c, idx) => c + pasoAdaptativo * k3[idx]));
                        siguienteEstado = estadoActual.map((c, idx) => c + (pasoAdaptativo / 6) * (k1[idx] + 2 * k2[idx] + 2 * k3[idx] + k4[idx]));
                    }

                    siguienteEstado = aplicarForzado(siguienteEstado);
                    tiempoActual += pasoAdaptativo;

                    tiempos.push(tiempoActual);
                    concentraciones.push(siguienteEstado.slice());
                    estadoActual = siguienteEstado;
                    derivadas = calcularDerivadas(estadoActual);
                    iteracion++;

                    evaluacion = evaluarCriteriosLimite(estadoActual, derivadas);
                    if (evaluacion.detener) {
                        conversionLimitante = evaluacion.conversion;
                        razonDetencion = evaluacion.razon;
                        tiempoFinalSegundos = tiempoActual;
                        finalizadoAutomaticamente = true;
                        break;
                    }
                }

                if (!finalizadoAutomaticamente) {
                    alert('No fue posible determinar el tiempo de reacción automáticamente con los criterios de conversión establecidos. Revise los parámetros de entrada.');
                    return;
                }

                // === Uniform time resampling (optional) ===
                if (tiempos.length > pasos + 1) {
                    const nuevoTiempos = [];
                    const nuevoConcentraciones = [];
                    const tiempoInicial = tiempos[0];
                    const tiempoFinal = tiempos[tiempos.length - 1];
                    let indiceBase = 0;

                    for (let i = 0; i <= pasos; i++) {
                        const proporcion = i / pasos;
                        const tiempoObjetivo = tiempoInicial + (tiempoFinal - tiempoInicial) * proporcion;

                        while (indiceBase < tiempos.length - 2 && tiempos[indiceBase + 1] < tiempoObjetivo) {
                            indiceBase++;
                        }

                        const tiempoA = tiempos[indiceBase];
                        const tiempoB = tiempos[indiceBase + 1] ?? tiempoA;
                        const peso = (tiempoB === tiempoA) ? 0 : (tiempoObjetivo - tiempoA) / (tiempoB - tiempoA);
                        const concentracionA = concentraciones[indiceBase];
                        const concentracionB = concentraciones[indiceBase + 1] ?? concentracionA;
                        const interpolado = concentracionA.map((valor, idx) => {
                            const valorB = concentracionB[idx] ?? valor;
                            return valor * (1 - peso) + valorB * peso;
                        });

                        nuevoTiempos.push(tiempoObjetivo);
                        nuevoConcentraciones.push(interpolado);
                    }

                    tiempos = nuevoTiempos;
                    concentraciones = nuevoConcentraciones;
                }
            } else {
                for (let i = 0; i < pasos; i++) {
                    let siguienteEstado;

                    if (metodoIntegracion === 'euler') {
                        const k1 = calcularDerivadas(estadoActual);
                        siguienteEstado = estadoActual.map((c, idx) => c + k1[idx] * dt);
                    } else {
                        const k1 = calcularDerivadas(estadoActual);
                        const k2 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * dt * k1[idx]));
                        const k3 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * dt * k2[idx]));
                        const k4 = calcularDerivadas(estadoActual.map((c, idx) => c + dt * k3[idx]));
                        siguienteEstado = estadoActual.map((c, idx) => c + (dt / 6) * (k1[idx] + 2 * k2[idx] + 2 * k3[idx] + k4[idx]));
                    }

                    siguienteEstado = aplicarForzado(siguienteEstado);
                    tiempoActual += dt;

                    tiempos.push(tiempoActual);
                    concentraciones.push(siguienteEstado.slice());
                    estadoActual = siguienteEstado;
                }
            }

            if (infoReactivoLimitante && concentraciones.length > 0) {
                const concentracionFinalLimitante = Math.max(concentraciones[concentraciones.length - 1][infoReactivoLimitante.idx], 0);
                if (infoReactivoLimitante.concentracionInicial > 0) {
                    conversionLimitante = Math.min(
                        100,
                        Math.max(
                            0,
                            (1 - (concentracionFinalLimitante / infoReactivoLimitante.concentracionInicial)) * 100
                        )
                    );
                } else {
                    conversionLimitante = concentracionFinalLimitante === 0 ? 100 : 0;
                }
            }

            if (!razonDetencion) {
                razonDetencion = autoTiempo ? 'Integration completed' : 'User-defined final time'; // === Isolation & limiting-reactant stop rule ===
            }

            const aislamientoLista = Array.from(isolationSet).sort((a, b) => a - b).map(idx => `Especie ${idx + 1}`); // === Catalyst feature ===
            const catalizadorLista = Array.from(catalystSet).sort((a, b) => a - b).map(idx => `Especie ${idx + 1}`); // === Catalyst feature ===
            const aislamientoTexto = aislamientoLista.length > 0 ? aislamientoLista.join(', ') : 'None'; // === Catalyst feature ===
            const catalizadorTexto = catalizadorLista.length > 0 ? catalizadorLista.join(', ') : 'None'; // === Catalyst feature ===
            const statusElement = document.getElementById('limitingStatus'); // === Isolation & limiting-reactant stop rule ===
            if (statusElement) {
                if (infoReactivoLimitante) {
                    const conversionTexto = conversionLimitante !== null ? conversionLimitante.toFixed(4) : 'N/A';
                    statusElement.textContent = `Limiting reactant: Especie ${infoReactivoLimitante.idx + 1}. Final conversion: ${conversionTexto}%. Stop reason: ${razonDetencion}. Isolation set: [${aislamientoTexto}]. Catalyst set: [${catalizadorTexto}].`; // === Catalyst feature ===
                } else {
                    statusElement.textContent = `Limiting reactant: N/A. Final conversion: N/A. Stop reason: ${razonDetencion}. Isolation set: [${aislamientoTexto}]. Catalyst set: [${catalizadorTexto}].`; // === Catalyst feature ===
                }
            }

            // Extraer las concentraciones del reactivo seleccionado
            let concentracionReactivoBase = concentraciones.map(c => c[reactivoBase]);

            // Convertir el vector de tiempo de vuelta a la unidad seleccionada por el usuario
            let factorTiempo = 1;
            if (unidadTiempo === 'min') {
                factorTiempo = 60;
            } else if (unidadTiempo === 'h') {
                factorTiempo = 3600;
            }

            tiempos = tiempos.map(tiempo => tiempo / factorTiempo);

            if (autoTiempo) {
                const tiempoFinalConvertido = tiempoFinalSegundos / factorTiempo;
                if (!isNaN(tiempoFinalConvertido) && isFinite(tiempoFinalConvertido)) {
                    document.getElementById('tiempoFinal').value = tiempoFinalConvertido.toFixed(4);
                }
            }

            // Guardar los resultados para el CSV
            resultados = tiempos.map((tiempo, index) => [tiempo, ...concentraciones[index]]);

            // Graficar los resultados
            const ctx = document.getElementById('grafica').getContext('2d');
            if (grafica) grafica.destroy();  // Destruir la gráfica anterior si existe
            grafica = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: tiempos.map(time => time.toFixed(2)), // Redondear los valores de tiempo a 2 decimales
                    datasets: [{
                        label: `Concentración de la Especie ${reactivoBase + 1} (${unidadConcentracion})`,
                        data: concentracionReactivoBase,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        fill: false,
                    }]
                },
                options: {
                    scales: {
                        x: { 
                            title: { display: true, text: `Tiempo (${unidadTiempo})` }
                        },
                        y: { 
                            title: { display: true, text: `Concentración (${unidadConcentracion})` }
                        }
                    }
                }
            });
        }

        // Función para limpiar la gráfica y los resultados
        function limpiar() {
            if (grafica) grafica.destroy();  // Destruir la gráfica actual
            document.getElementById('grafica').getContext('2d').clearRect(0, 0, 400, 400);  // Limpiar el canvas
            resultados = [];  // Borrar los resultados
            const statusElement = document.getElementById('limitingStatus'); // === Isolation & limiting-reactant stop rule ===
            if (statusElement) {
                statusElement.textContent = '';
            }
        }

        // Función para descargar los resultados como un archivo CSV
        function descargarCSV() {
            if (resultados.length === 0) {
                alert("No hay resultados para descargar.");
                return;
            }

            const notacion = document.getElementById("notacionDecimal").value;

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tiempo;Concentraciones\n";  // Encabezado con punto y coma como separador

            resultados.forEach((fila) => {
                const filaFormateada = fila.map(num => {
                    let strNum = num.toFixed(4); // Convertir a cadena con 4 decimales
                    if (notacion === "coma") {
                        strNum = strNum.replace('.', ','); // Reemplazar punto por coma
                    }
                    return strNum;
                });
                csvContent += filaFormateada.join(";") + "\n";  // Agregar cada fila de datos usando punto y coma
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "resultados_cinetica.csv");
            document.body.appendChild(link);  // Necesario para hacer clic en el enlace
            link.click();  // Descargar el archivo
        }

        const checkboxTiempoAutomatico = document.getElementById('tiempoAutomatico');
        const manejarCambioTiempoAutomatico = (evento) => {
            document.getElementById('tiempoFinal').disabled = evento.target.checked;
        };

        checkboxTiempoAutomatico.addEventListener('change', manejarCambioTiempoAutomatico);

        // Inicializar el formulario
        actualizarFormulario();
        manejarCambioTiempoAutomatico({ target: checkboxTiempoAutomatico });
    </script>
</body>
</html>
