<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Cin√©tica Qu√≠mica</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.2.1/lib/browser/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            /* === Theme palette (light default) === */
            --bg: #f4f4f9;
            --card: #ffffff;
            --text: #1a1a1a;
            --muted: #5a5a72;
            --brand: #005fcc;
            --brand-600: #004099;
            --accent: #ffbf47;
            --grid: rgba(26, 26, 26, 0.15);
            --row: rgba(0, 95, 204, 0.08);
        }

        :root[data-theme="dark"] {
            --bg: #10131a;
            --card: #1a1f2b;
            --text: #f4f6fb;
            --muted: #a9b3ce;
            --brand: #3b82f6;
            --brand-600: #2563eb;
            --accent: #facc15;
            --grid: rgba(244, 246, 251, 0.25);
            --row: rgba(59, 130, 246, 0.12);
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 20px;
            max-width: 95%;
            margin: 0 auto;
        }
        .left-panel, .right-panel {
            background-color: var(--card);
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.12);
            border-radius: 8px;
            flex: 1 1 320px;
        }
        .left-panel {
            max-width: 420px;
        }
        .right-panel {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        input, select, button {
            margin: 5px 0;
            padding: 8px;
            border: 1px solid var(--grid);
            border-radius: 4px;
            width: calc(100% - 20px);
            background-color: var(--card);
            color: var(--text);
        }
        input[type="checkbox"] {
            width: auto;
            margin-left: 0;
        }
        label {
            font-weight: bold;
            margin-top: 10px;
            display: inline-block;
        }
        .form-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .form-group label {
            flex: 1;
            margin-right: 10px;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table th, .species-table td {
            border: 1px solid var(--grid);
            padding: 6px;
            text-align: center;
            background-color: var(--card);
        }
        /* === Isolation & limiting-reactant stop rule === */
        .species-table input[type="number"] {
            width: 100%;
            box-sizing: border-box;
        }
        /* === Isolation & limiting-reactant stop rule === */
        .status-line {
            font-size: 0.95rem;
            margin-top: 15px;
            font-weight: 600;
            color: var(--text);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .form-group input, .form-group select {
            flex: 2;
        }
        button {
            background-color: var(--brand);
            color: #ffffff;
            cursor: pointer;
            border: none;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: var(--brand-600);
        }
        input:focus, select:focus, button:focus {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
        }
        canvas {
            width: 100%;
            height: 600px; /* Aumentar la altura de la gr√°fica */
        }
        sub {
            vertical-align: sub;
            font-size: smaller;
        }
        .advanced-settings {
            margin-top: 15px;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .button-group button {
            flex: 1 1 150px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .chip {
            background-color: var(--row);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .helper-text {
            font-size: 0.9rem;
            color: var(--muted);
            margin-top: 10px;
        }
        .title-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px;
        }
        #themeToggle {
            flex: 0 0 auto;
            padding: 8px 14px;
            font-size: 0.95rem;
        }
        .plot-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        .plot-controls label {
            font-weight: bold;
        }
        @media (max-width: 900px) {
            .container {
                justify-content: center;
            }
            .left-panel, .right-panel {
                max-width: 100%;
            }
            canvas {
                height: 400px;
            }
        }

        /* === Sticky left panel === */
        @media (min-width: 1000px) {
            .left-panel {
                position: sticky;
                top: 20px;
                align-self: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container" role="main" aria-labelledby="appTitle">
        <!-- Panel Izquierdo: Formulario -->
        <div class="left-panel" role="form" aria-describedby="keyboardInstructions">
            <div class="title-bar">
                <h1 id="appTitle">Simulador de Cin√©tica Qu√≠mica</h1>
                <button id="themeToggle" type="button" aria-label="Cambiar tema">Theme</button>
            </div>

            <div class="form-group">
                <label for="numReactivos">N√∫mero de reactivos:</label>
                <input type="number" id="numReactivos" value="1" min="1" onchange="actualizarFormulario()">
            </div>

            <div id="reactivosForm" aria-live="polite"></div>

            <div class="form-group">
                <label for="k">Constante de velocidad (k):</label>
                <input type="number" id="k" value="0.6" step="0.01">
            </div>

            <div class="form-group">
                <label for="unidadVelocidad">Unidad de constante de velocidad:</label>
                <select id="unidadVelocidad">
                    <option value="s">1/segundos</option>
                    <option value="min">1/minutos</option>
                    <option value="h">1/horas</option>
                </select>
            </div>

            <div class="form-group">
                <label for="tiempoFinal">Tiempo final (<i>t<sub>f</sub></i>):</label>
                <input type="number" id="tiempoFinal" value="10" step="1">
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="tiempoAutomatico">
                    Calcular autom√°ticamente el tiempo de reacci√≥n
                </label>
            </div>

            <div class="form-group">
                <label for="unidadTiempo">Unidad de tiempo de reacci√≥n:</label>
                <select id="unidadTiempo">
                    <option value="s">segundos</option>
                    <option value="min">minutos</option>
                    <option value="h">horas</option>
                </select>
            </div>

            <div class="form-group">
                <label for="unidadConcentracion">Unidad de concentraci√≥n:</label>
                <select id="unidadConcentracion">
                    <option value="M">Molar</option>
                    <option value="mM">mMolar</option>
                    <option value="uM">¬µMolar</option>
                </select>
            </div>

            <div class="form-group">
                <label for="reactivoBase">Especie para representar:</label>
                <select id="reactivoBase"></select>
            </div>

            <div class="plot-controls" aria-label="Opciones de representaci√≥n">
                <label for="plotMode">Modo de gr√°fico:</label>
                <select id="plotMode">
                    <option value="all" selected>All species</option>
                    <option value="selected">Only selected</option>
                </select>
            </div>

            <!-- === Toolbar icons === -->
            <div class="form-group button-group" role="group" aria-label="Acciones del simulador">
                <button onclick="simular()" aria-label="Calcular reacci√≥n">
                    <span aria-hidden="true">‚ñ∂Ô∏è</span>
                    <span>Calcular</span>
                </button>
                <button onclick="limpiar()" aria-label="Limpiar resultados">
                    <span aria-hidden="true">üßπ</span>
                    <span>Limpiar</span>
                </button>
                <button onclick="descargarCSV()" aria-label="Descargar resultados en CSV">
                    <span aria-hidden="true">üíæ</span>
                    <span>CSV</span>
                </button>
            </div>

            <p class="helper-text" id="keyboardInstructions">Usa la tecla Tab para navegar entre los controles y Enter o la barra espaciadora para activar los botones.</p>
            <!-- === Isolation & limiting-reactant stop rule === -->
            <p id="limitingStatus" class="status-line" aria-live="polite"></p>

            <div class="form-group">
                <label for="notacionDecimal">Notaci√≥n decimal:</label>
                <select id="notacionDecimal">
                    <option value="punto">Punto decimal</option>
                    <option value="coma">Coma decimal</option>
                </select>
            </div>

            <details class="advanced-settings">
                <summary>Configuraci√≥n avanzada</summary>
                <div class="form-group">
                    <label for="metodoIntegracion">M√©todo num√©rico:</label>
                    <select id="metodoIntegracion">
                        <option value="rk4" selected>Runge-Kutta 4¬∫ orden</option>
                        <option value="euler">Euler hacia adelante</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="numPuntos">Puntos de c√°lculo:</label>
                    <input type="number" id="numPuntos" value="200" min="10" step="10">
                </div>
                <div class="form-group">
                    <label for="forzarNoNegativas">Forzar concentraciones no negativas:</label>
                    <input type="checkbox" id="forzarNoNegativas" checked>
                </div>
                <!-- === Isolation & limiting-reactant stop rule === -->
                <div class="form-group">
                    <label for="salvaguardaDerivada">Detener si |dC<sub>lim</sub>/dt| ‚â§ 1e-12:</label>
                    <input type="checkbox" id="salvaguardaDerivada">
                </div>
            </details>
        </div>

        <!-- Panel Derecho: Gr√°fica -->
        <div class="right-panel" role="region" aria-label="Gr√°fico de resultados">
            <canvas id="grafica"></canvas>
        </div>
    </div>

    <script>
        let grafica;  // Variable para la gr√°fica
        let resultados = [];  // Almacenar resultados para CSV
        let datosSimulacion = null; // === Chart state cache ===

        // === Theme toggle ===
        const root = document.documentElement;
        const themeToggleBtn = document.getElementById('themeToggle');
        if (themeToggleBtn) {
            themeToggleBtn.addEventListener('click', () => {
                root.dataset.theme = root.dataset.theme === 'dark' ? '' : 'dark';
                if (datosSimulacion) {
                    reconstruirGrafica();
                }
            });
        }

        // === Plot mode selector wiring ===
        const plotModeSelect = document.getElementById('plotMode');
        const reactivoBaseSelect = document.getElementById('reactivoBase');
        if (plotModeSelect) {
            plotModeSelect.addEventListener('change', () => {
                if (datosSimulacion) {
                    reconstruirGrafica();
                }
            });
        }
        if (reactivoBaseSelect) {
            reactivoBaseSelect.addEventListener('change', () => {
                if (datosSimulacion) {
                    datosSimulacion.reactivoBase = parseInt(reactivoBaseSelect.value, 10) || 0;
                    reconstruirGrafica();
                }
            });
        }

        // === Status chips ===
        function crearChip(etiqueta, valor) {
            const safeValor = valor ? valor : 'N/A';
            return `<span class="chip"><strong>${etiqueta}:</strong> <span>${safeValor}</span></span>`;
        }

        function actualizarChipsEstado({
            infoReactivoLimitante,
            conversionLimitante,
            razonDetencion,
            aislamientoTexto,
            catalizadorTexto
        }) {
            const statusElement = document.getElementById('limitingStatus');
            if (!statusElement) return;

            if (!infoReactivoLimitante && !razonDetencion) {
                statusElement.innerHTML = '';
                return;
            }

            const chips = [];
            const limitante = infoReactivoLimitante ? `Especie ${infoReactivoLimitante.idx + 1}` : 'N/A';
            const conversionTexto = typeof conversionLimitante === 'number' && !Number.isNaN(conversionLimitante)
                ? `${conversionLimitante.toFixed(4)}%`
                : 'N/A';
            chips.push(crearChip('Reactivo limitante', limitante));
            chips.push(crearChip('Conversi√≥n final', conversionTexto));
            chips.push(crearChip('Motivo de detenci√≥n', razonDetencion || 'N/A'));
            chips.push(crearChip('Isolation set', aislamientoTexto ? `[${aislamientoTexto}]` : '[None]'));
            chips.push(crearChip('Catalyst set', catalizadorTexto ? `[${catalizadorTexto}]` : '[None]'));

            statusElement.innerHTML = chips.join('');
        }

        // === Chart: plotMode all/selected ===
        function buildChart({ plotMode, tiempos, concentraciones, reactivoBase, unidadTiempo, unidadConcentracion }) {
            const ctx = document.getElementById('grafica').getContext('2d');
            if (grafica) grafica.destroy();

            const estilos = getComputedStyle(document.documentElement);
            const gridColor = estilos.getPropertyValue('--grid').trim() || 'rgba(0,0,0,0.1)';
            const textoColor = estilos.getPropertyValue('--text').trim() || '#1a1a1a';

            const totalEspecies = concentraciones.length > 0 ? concentraciones[0].length : 0;
            const datasets = [];
            const baseHue = 210;
            const hueStep = 35;

            const agregarDataset = (indice) => {
                const hue = (baseHue + hueStep * indice) % 360;
                const color = `hsl(${hue}, 70%, 50%)`;
                datasets.push({
                    label: `Especie ${indice + 1} (${unidadConcentracion})`,
                    data: concentraciones.map(fila => fila[indice]),
                    borderColor: color,
                    backgroundColor: 'transparent',
                    borderWidth: indice === reactivoBase ? 3 : 1.8,
                    tension: 0.22,
                    pointRadius: 0,
                    spanGaps: true
                });
            };

            if (plotMode === 'selected') {
                if (reactivoBase >= 0 && reactivoBase < totalEspecies) {
                    agregarDataset(reactivoBase);
                }
            } else {
                for (let i = 0; i < totalEspecies; i++) {
                    agregarDataset(i);
                }
            }

            grafica = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: tiempos.map(time => Number.isFinite(time) ? time.toFixed(2) : time),
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: `Tiempo (${unidadTiempo})`, color: textoColor },
                            ticks: { color: textoColor },
                            grid: { color: gridColor }
                        },
                        y: {
                            title: { display: true, text: `Concentraci√≥n (${unidadConcentracion})`, color: textoColor },
                            ticks: { color: textoColor },
                            grid: { color: gridColor }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: textoColor
                            }
                        }
                    }
                }
            });
        }

        function reconstruirGrafica() {
            if (!datosSimulacion) return;
            const plotMode = plotModeSelect ? plotModeSelect.value : 'all';
            buildChart({
                plotMode,
                tiempos: datosSimulacion.tiempos,
                concentraciones: datosSimulacion.concentraciones,
                reactivoBase: datosSimulacion.reactivoBase,
                unidadTiempo: datosSimulacion.unidadTiempo,
                unidadConcentracion: datosSimulacion.unidadConcentracion
            });
        }

        // === Isolation & limiting-reactant stop rule ===
        function getCheckedIsolationSet() {
            const set = new Set();
            document.querySelectorAll('.cbIsolation').forEach((checkbox) => {
                if (checkbox.checked) {
                    const idx = parseInt(checkbox.dataset.idx, 10);
                    if (!Number.isNaN(idx)) {
                        set.add(idx);
                    }
                }
            });
            return set;
        }

        // === Catalyst feature ===
        function getCatalystSet() {
            const set = new Set();
            document.querySelectorAll('.cbCatalyst').forEach((checkbox) => {
                if (checkbox.checked) {
                    const idx = parseInt(checkbox.dataset.idx, 10);
                    if (!Number.isNaN(idx)) {
                        set.add(idx);
                    }
                }
            });
            return set;
        }

        // === Isolation & limiting-reactant stop rule ===
        function obtenerParametrosReactivos() {
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10) || 0;
            const concentraciones = [];
            const coeficientes = [];

            for (let i = 0; i < numReactivos; i++) {
                const conc = parseFloat(document.getElementById(`C0${i}`)?.value);
                const coef = parseFloat(document.getElementById(`stoich${i}`)?.value);
                concentraciones.push(Number.isNaN(conc) ? 0 : conc);
                coeficientes.push(Number.isNaN(coef) ? 0 : coef);
            }

            return { concentraciones, coeficientes };
        }

        // === Isolation & limiting-reactant stop rule ===
        function validateIsolation(coeficientes, concentraciones, isolationSet) {
            const mensajes = [];
            const validado = new Set(isolationSet);
            const reactantes = [];
            const razones = new Map();

            coeficientes.forEach((coef, idx) => {
                if (coef < 0) {
                    const absCoef = Math.abs(coef);
                    const conc = Math.max(concentraciones[idx] || 0, 0);
                    const ratio = absCoef > 0 ? conc / absCoef : Infinity;
                    reactantes.push(idx);
                    razones.set(idx, ratio);
                }
            });

            if (reactantes.length === 0) {
                return { validatedSet: validado, mensajes };
            }

            const noAislados = reactantes.filter(idx => !validado.has(idx));

            if (noAislados.length === 0 && validado.size > 0) {
                let mejor = null;
                validado.forEach((idx) => {
                    if (!razones.has(idx)) {
                        return;
                    }
                    const ratio = razones.get(idx);
                    if (!mejor || ratio > mejor.ratio) {
                        mejor = { idx, ratio };
                    }
                });
                validado.forEach((idx) => {
                    if (!mejor || idx === mejor.idx) {
                        return;
                    }
                    validado.delete(idx);
                });
                if (mejor && validado.size === reactantes.length) {
                    validado.delete(mejor.idx);
                    mensajes.push('No es posible aislar todos los reactivos. Se desmarcaron todas las especies para mantener al menos un reactivo no aislado.');
                } else if (mejor) {
                    mensajes.push(`No es posible aislar todos los reactivos. Solo se mantiene aislada la Especie ${mejor.idx + 1}.`);
                } else {
                    mensajes.push('No es posible aislar todos los reactivos. Se desmarcaron las selecciones.');
                    validado.clear();
                }
                return { validatedSet: validado, mensajes };
            }

            if (noAislados.length > 0) {
                const Rmin = Math.min(...noAislados.map(idx => razones.get(idx) ?? Infinity));
                const especiesInvalidas = [];
                validado.forEach((idx) => {
                    if (!razones.has(idx)) {
                        return;
                    }
                    const ratio = razones.get(idx);
                    if (ratio < 10 * Rmin) {
                        validado.delete(idx);
                        especiesInvalidas.push(`Especie ${idx + 1}`);
                    }
                });
                if (especiesInvalidas.length > 0) {
                    mensajes.push(`Las siguientes especies no cumplen la condici√≥n 10:1 y fueron desmarcadas: ${especiesInvalidas.join(', ')}. Se requiere R_i ‚â• 10 √ó R_min.`);
                }
            }

            return { validatedSet: validado, mensajes };
        }

        // === Isolation & limiting-reactant stop rule ===
        function buildIsolationSetValidated(coeficientes, concentraciones, opciones = {}) {
            const aislamientoActual = getCheckedIsolationSet();
            const { validatedSet, mensajes } = validateIsolation(coeficientes, concentraciones, aislamientoActual);

            document.querySelectorAll('.cbIsolation').forEach((checkbox) => {
                const idx = parseInt(checkbox.dataset.idx, 10);
                checkbox.checked = validatedSet.has(idx);
            });

            if (mensajes.length > 0 && !opciones.silencioso) {
                alert(mensajes.join('\n'));
            }

            return validatedSet;
        }

        // === Isolation & limiting-reactant stop rule ===
        function manejarCambioIsolation(opciones = {}) {
            const { concentraciones, coeficientes } = obtenerParametrosReactivos();
            buildIsolationSetValidated(coeficientes, concentraciones, opciones);
        }

        // === Catalyst feature ===
        function manejarCambioIsolationCheckbox(evento) {
            const checkbox = evento.target;
            if (!checkbox) return;
            if (checkbox.checked) {
                const idx = parseInt(checkbox.dataset.idx, 10);
                const catalystCheckbox = document.querySelector(`.cbCatalyst[data-idx="${idx}"]`);
                if (catalystCheckbox && catalystCheckbox.checked) {
                    checkbox.checked = false;
                    alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
                }
            }
            manejarCambioIsolation();
        }

        // === Catalyst feature ===
        function manejarCambioCatalystCheckbox(evento) {
            const checkbox = evento.target;
            if (!checkbox) return;
            if (checkbox.checked) {
                const idx = parseInt(checkbox.dataset.idx, 10);
                const isolationCheckbox = document.querySelector(`.cbIsolation[data-idx="${idx}"]`);
                if (isolationCheckbox && isolationCheckbox.checked) {
                    isolationCheckbox.checked = false;
                    alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
                }
            }
            manejarCambioIsolation();
        }

        // Actualiza el formulario seg√∫n el n√∫mero de reactivos
        function actualizarFormulario() {
            // === Isolation & limiting-reactant stop rule ===
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10) || 0;
            const reactivosForm = document.getElementById('reactivosForm');
            const reactivoBaseSelect = document.getElementById('reactivoBase');
            reactivosForm.innerHTML = '';
            reactivoBaseSelect.innerHTML = '';

            const tabla = document.createElement('table');
            tabla.className = 'species-table';

            const thead = document.createElement('thead');
            thead.innerHTML = '<tr><th>Especie</th><th>Orden</th><th>[A]<sub>0</sub></th><th>ŒΩ</th><th>Isolation</th><th>Catalyst</th></tr>'; // === Catalyst feature ===
            tabla.appendChild(thead);

            const tbody = document.createElement('tbody');

            for (let i = 0; i < numReactivos; i++) {
                const fila = document.createElement('tr');

                const celdaNombre = document.createElement('td');
                celdaNombre.textContent = `Especie ${i + 1}`;
                fila.appendChild(celdaNombre);

                const celdaOrden = document.createElement('td');
                const inputOrden = document.createElement('input');
                inputOrden.type = 'number';
                inputOrden.id = `orden${i}`;
                inputOrden.value = '1';
                inputOrden.step = '0.1';
                inputOrden.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaOrden.appendChild(inputOrden);
                fila.appendChild(celdaOrden);

                const celdaConcentracion = document.createElement('td');
                const inputConcentracion = document.createElement('input');
                inputConcentracion.type = 'number';
                inputConcentracion.id = `C0${i}`;
                inputConcentracion.value = '1';
                inputConcentracion.step = '0.1';
                inputConcentracion.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaConcentracion.appendChild(inputConcentracion);
                fila.appendChild(celdaConcentracion);

                const celdaStoich = document.createElement('td');
                const inputStoich = document.createElement('input');
                inputStoich.type = 'number';
                inputStoich.id = `stoich${i}`;
                inputStoich.value = '-1';
                inputStoich.step = '0.1';
                inputStoich.addEventListener('input', () => manejarCambioIsolation({ silencioso: true }));
                celdaStoich.appendChild(inputStoich);
                fila.appendChild(celdaStoich);

                const celdaIsolation = document.createElement('td');
                const checkboxIsolation = document.createElement('input');
                checkboxIsolation.type = 'checkbox';
                checkboxIsolation.className = 'cbIsolation';
                checkboxIsolation.dataset.idx = i;
                checkboxIsolation.addEventListener('change', manejarCambioIsolationCheckbox); // === Catalyst feature ===
                celdaIsolation.appendChild(checkboxIsolation);
                fila.appendChild(celdaIsolation);

                const celdaCatalyst = document.createElement('td'); // === Catalyst feature ===
                const checkboxCatalyst = document.createElement('input'); // === Catalyst feature ===
                checkboxCatalyst.type = 'checkbox'; // === Catalyst feature ===
                checkboxCatalyst.className = 'cbCatalyst'; // === Catalyst feature ===
                checkboxCatalyst.dataset.idx = i; // === Catalyst feature ===
                checkboxCatalyst.addEventListener('change', manejarCambioCatalystCheckbox); // === Catalyst feature ===
                celdaCatalyst.appendChild(checkboxCatalyst); // === Catalyst feature ===
                fila.appendChild(celdaCatalyst); // === Catalyst feature ===

                tbody.appendChild(fila);

                reactivoBaseSelect.innerHTML += `<option value="${i}">Especie ${i + 1}</option>`;
            }

            tabla.appendChild(tbody);
            reactivosForm.appendChild(tabla);

            manejarCambioIsolation();
        }

        // Funci√≥n para resolver las ecuaciones y graficar los resultados
        function simular() {
            const numReactivos = parseInt(document.getElementById('numReactivos').value, 10);
            const k = parseFloat(document.getElementById('k').value);
            const unidadVelocidad = document.getElementById('unidadVelocidad').value;
            const tiempoFinal = parseFloat(document.getElementById('tiempoFinal').value);
            const unidadTiempo = document.getElementById('unidadTiempo').value;
            const unidadConcentracion = document.getElementById('unidadConcentracion').value;
            const reactivoBase = parseInt(document.getElementById('reactivoBase').value);
            const metodoIntegracion = document.getElementById('metodoIntegracion').value;
            const numPuntos = parseInt(document.getElementById('numPuntos').value, 10);
            const forzarNoNegativas = document.getElementById('forzarNoNegativas').checked;
            const autoTiempo = document.getElementById('tiempoAutomatico').checked;
            const usarSalvaguardaDerivada = document.getElementById('salvaguardaDerivada').checked; // === Isolation & limiting-reactant stop rule ===

            if (isNaN(numPuntos) || numPuntos < 1) {
                alert('El n√∫mero de puntos de c√°lculo debe ser un entero positivo.');
                return;
            }

            let ordenes = [];
            let concentracionesIniciales = [];
            let coeficientesEstequiometricos = [];

            for (let i = 0; i < numReactivos; i++) {
                const orden = parseFloat(document.getElementById(`orden${i}`).value);
                const concentracionInicial = parseFloat(document.getElementById(`C0${i}`).value);
                const coeficiente = parseFloat(document.getElementById(`stoich${i}`).value);

                if (isNaN(orden) || isNaN(concentracionInicial) || isNaN(coeficiente)) {
                    alert(`Todos los par√°metros del reactivo ${i + 1} deben ser valores num√©ricos.`);
                    return;
                }

                ordenes.push(orden);
                concentracionesIniciales.push(concentracionInicial);
                coeficientesEstequiometricos.push(coeficiente);
            }

            const C0 = concentracionesIniciales.slice(); // === Catalyst feature ===
            const isolationSet = buildIsolationSetValidated(coeficientesEstequiometricos, concentracionesIniciales); // === Isolation & limiting-reactant stop rule ===
            const catalystSet = getCatalystSet(); // === Catalyst feature ===

            // === Catalyst feature ===
            const indicesSuperpuestos = [];
            isolationSet.forEach((idx) => {
                if (catalystSet.has(idx)) {
                    indicesSuperpuestos.push(idx);
                }
            });
            if (indicesSuperpuestos.length > 0) {
                indicesSuperpuestos.forEach((idx) => {
                    isolationSet.delete(idx);
                    const isolationCheckbox = document.querySelector(`.cbIsolation[data-idx="${idx}"]`);
                    if (isolationCheckbox) {
                        isolationCheckbox.checked = false;
                    }
                });
                alert('A species cannot be both Isolation and Catalyst; kept Catalyst.');
            }

            const especiesConstantes = new Set([...isolationSet, ...catalystSet]); // === Catalyst feature ===

            // Conversi√≥n de unidades de la constante de velocidad
            let kConvertido = k;
            if (unidadVelocidad === 'min') {
                kConvertido = k / 60;  // Convertir de 1/minutos a 1/segundos
            } else if (unidadVelocidad === 'h') {
                kConvertido = k / 3600;  // Convertir de 1/horas a 1/segundos
            }

            if (!autoTiempo && (isNaN(tiempoFinal) || tiempoFinal <= 0)) {
                alert('El tiempo final debe ser un n√∫mero positivo.');
                return;
            }

            // Conversi√≥n de tiempo de reacci√≥n a segundos
            let tiempoFinalSegundos = null;
            if (!autoTiempo) {
                tiempoFinalSegundos = tiempoFinal;
                if (unidadTiempo === 'min') {
                    tiempoFinalSegundos = tiempoFinal * 60;  // Convertir de minutos a segundos
                } else if (unidadTiempo === 'h') {
                    tiempoFinalSegundos = tiempoFinal * 3600;  // Convertir de horas a segundos
                }
            }

            // Resolver ecuaciones diferenciales para cada reactivo usando el m√©todo seleccionado
            const pasos = Math.max(numPuntos, 1);
            const dt = autoTiempo || tiempoFinalSegundos === null ? null : tiempoFinalSegundos / pasos;
            let tiempos = [];
            let concentraciones = [];

            const reactivosEstequiometricos = coeficientesEstequiometricos
                .map((coef, idx) => ({ coef, idx }))
                .filter(item => item.coef < 0);

            let reactivosNoAislados = reactivosEstequiometricos.filter(item => !especiesConstantes.has(item.idx)); // === Catalyst feature ===
            if (reactivosNoAislados.length === 0) { // === Catalyst feature ===
                const candidatosCatalyst = reactivosEstequiometricos.filter(item => catalystSet.has(item.idx));
                if (candidatosCatalyst.length > 0) {
                    let mejor = null;
                    candidatosCatalyst.forEach((item) => {
                        const ratio = Math.abs(item.coef) > 0 ? Math.max(C0[item.idx], 0) / Math.abs(item.coef) : -Infinity;
                        if (!mejor || ratio > mejor.ratio) {
                            mejor = { idx: item.idx, ratio };
                        }
                    });
                    if (mejor) {
                        catalystSet.delete(mejor.idx);
                        const catalystCheckbox = document.querySelector(`.cbCatalyst[data-idx="${mejor.idx}"]`);
                        if (catalystCheckbox) {
                            catalystCheckbox.checked = false;
                        }
                        alert('Al menos un reactivo debe permanecer libre. Se desmarc√≥ el catalizador con mayor R_i para continuar.');
                        reactivosNoAislados = reactivosEstequiometricos.filter(item => !isolationSet.has(item.idx) && !catalystSet.has(item.idx));
                        especiesConstantes.clear();
                        isolationSet.forEach(idx => especiesConstantes.add(idx));
                        catalystSet.forEach(idx => especiesConstantes.add(idx));
                    }
                }
            }

            if (reactivosNoAislados.length === 0) { // === Catalyst feature ===
                alert('Debe dejar al menos un reactivo que no sea aislado ni catalizador para continuar con la simulaci√≥n.');
                return;
            }
            const fraccionRestanteLimitante = 1e-3; // === Isolation & limiting-reactant stop rule ===
            const umbralAbsolutoLimitante = 1e-9; // === Isolation & limiting-reactant stop rule ===

            let infoReactivoLimitante = null;
            if (reactivosNoAislados.length > 0) {
                infoReactivoLimitante = reactivosNoAislados.reduce((limitante, item) => {
                    const coefAbs = Math.abs(item.coef);
                    const concentracionInicial = Math.max(C0[item.idx], 0); // === Catalyst feature ===
                    const ratio = coefAbs > 0 ? concentracionInicial / coefAbs : Infinity;

                    if (!limitante || ratio < limitante.ratio) {
                        return {
                            idx: item.idx,
                            coef: item.coef,
                            ratio,
                            concentracionInicial,
                        };
                    }
                    return limitante;
                }, null);

                if (infoReactivoLimitante) {
                    infoReactivoLimitante.umbralRelativo = infoReactivoLimitante.concentracionInicial * fraccionRestanteLimitante;
                    infoReactivoLimitante.umbralAbsoluto = umbralAbsolutoLimitante;
                    infoReactivoLimitante.fraccionRestante = fraccionRestanteLimitante;
                }
            }

            let conversionLimitante = null;
            let razonDetencion = null; // === Isolation & limiting-reactant stop rule ===

            const calcularDerivadas = (estado) => {
                // === Isolation & limiting-reactant stop rule ===
                const concentracionesEfectivas = estado.map((valor, idx) => {
                    if (isolationSet.has(idx) || catalystSet.has(idx)) { // === Catalyst feature ===
                        return Math.max(C0[idx], 0); // === Catalyst feature ===
                    }
                    return Math.max(valor, 0);
                });
                const producto = concentracionesEfectivas.reduce((acc, C, idx) => acc * Math.pow(C, ordenes[idx]), 1);
                const velocidad = kConvertido * producto;
                return estado.map((_, idx) => {
                    if (especiesConstantes.has(idx)) {
                        return 0;
                    }
                    return coeficientesEstequiometricos[idx] * velocidad;
                });
            };

            const evaluarCriteriosLimite = (estado, derivadasLocales) => {
                // === Isolation & limiting-reactant stop rule ===
                if (!infoReactivoLimitante) {
                    return { detener: false };
                }
                const indice = infoReactivoLimitante.idx;
                const concentracion = Math.max(estado[indice], 0);
                const umbralRelativo = infoReactivoLimitante.umbralRelativo;
                const umbralAbsoluto = infoReactivoLimitante.umbralAbsoluto;
                const derivadaAbs = Math.abs(derivadasLocales[indice] || 0);

                let razon = null;
                if (concentracion <= umbralRelativo) {
                    razon = '99.9% conversion';
                } else if (concentracion <= umbralAbsoluto) {
                    razon = 'Absolute safety floor';
                } else if (usarSalvaguardaDerivada && derivadaAbs <= 1e-12) {
                    razon = 'Derivative safeguard';
                }

                if (!razon) {
                    return { detener: false };
                }

                let conversion = 0;
                if (infoReactivoLimitante.concentracionInicial > 0) {
                    conversion = (1 - (concentracion / infoReactivoLimitante.concentracionInicial)) * 100;
                } else {
                    conversion = concentracion === 0 ? 100 : 0;
                }
                conversion = Math.max(0, Math.min(100, conversion));

                return { detener: true, razon, conversion };
            };

            const aplicarForzado = (estado) => {
                if (!forzarNoNegativas) return estado;
                return estado.map(valor => Math.max(valor, 0));
            };

            let estadoActual = concentracionesIniciales.slice();
            let tiempoActual = 0;

            tiempos.push(tiempoActual);
            concentraciones.push(estadoActual.slice());

            if (autoTiempo) {
                // === Isolation & limiting-reactant stop rule ===
                if (!infoReactivoLimitante) {
                    if (reactivosEstequiometricos.length > 0 && reactivosNoAislados.length === 0) {
                        alert('Todos los reactivos han sido marcados como aislados o catalizadores. Debe dejar al menos un reactivo libre para determinar el reactivo limitante.'); // === Catalyst feature ===
                    } else {
                        alert('Debe definir al menos un reactivo con coeficiente estequiom√©trico negativo para identificar el reactivo limitante.');
                    }
                    return;
                }

                const indicesReactivos = reactivosEstequiometricos;
                const tolerancia = 1e-8;
                const maxIteraciones = Math.max(pasos * 20, 1000);
                let iteracion = 0;
                let finalizadoAutomaticamente = false;

                let derivadas = calcularDerivadas(estadoActual);
                let evaluacion = evaluarCriteriosLimite(estadoActual, derivadas); // === Isolation & limiting-reactant stop rule ===
                if (evaluacion.detener) {
                    conversionLimitante = evaluacion.conversion;
                    razonDetencion = evaluacion.razon;
                    tiempoFinalSegundos = tiempoActual;
                    finalizadoAutomaticamente = true;
                }

                while (!finalizadoAutomaticamente && iteracion < maxIteraciones) {
                    const tiemposHastaCero = indicesReactivos.map(({ idx }) => {
                        const derivada = derivadas[idx];
                        if (derivada >= 0) return Infinity;
                        const concentracion = Math.max(estadoActual[idx], 0);
                        return concentracion / Math.abs(derivada);
                    });

                    const minimoTiempoHastaCero = Math.min(...tiemposHastaCero);

                    if (!isFinite(minimoTiempoHastaCero) || minimoTiempoHastaCero === Infinity) {
                        break;
                    }

                    let pasoAdaptativo = Math.min(minimoTiempoHastaCero / 5, minimoTiempoHastaCero);
                    pasoAdaptativo = Math.max(pasoAdaptativo, tolerancia);

                    let siguienteEstado;
                    if (metodoIntegracion === 'euler') {
                        const k1 = derivadas;
                        siguienteEstado = estadoActual.map((c, idx) => c + k1[idx] * pasoAdaptativo);
                    } else {
                        const k1 = derivadas;
                        const k2 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * pasoAdaptativo * k1[idx]));
                        const k3 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * pasoAdaptativo * k2[idx]));
                        const k4 = calcularDerivadas(estadoActual.map((c, idx) => c + pasoAdaptativo * k3[idx]));
                        siguienteEstado = estadoActual.map((c, idx) => c + (pasoAdaptativo / 6) * (k1[idx] + 2 * k2[idx] + 2 * k3[idx] + k4[idx]));
                    }

                    siguienteEstado = aplicarForzado(siguienteEstado);
                    tiempoActual += pasoAdaptativo;

                    tiempos.push(tiempoActual);
                    concentraciones.push(siguienteEstado.slice());
                    estadoActual = siguienteEstado;
                    derivadas = calcularDerivadas(estadoActual);
                    iteracion++;

                    evaluacion = evaluarCriteriosLimite(estadoActual, derivadas);
                    if (evaluacion.detener) {
                        conversionLimitante = evaluacion.conversion;
                        razonDetencion = evaluacion.razon;
                        tiempoFinalSegundos = tiempoActual;
                        finalizadoAutomaticamente = true;
                        break;
                    }
                }

                if (!finalizadoAutomaticamente) {
                    alert('No fue posible determinar el tiempo de reacci√≥n autom√°ticamente con los criterios de conversi√≥n establecidos. Revise los par√°metros de entrada.');
                    return;
                }

                if (tiempos.length > pasos + 1) {
                    const nuevoTiempos = [];
                    const nuevoConcentraciones = [];
                    const pasoMuestreo = (tiempos.length - 1) / pasos;

                    for (let i = 0; i <= pasos; i++) {
                        const indice = Math.min(Math.round(i * pasoMuestreo), tiempos.length - 1);
                        nuevoTiempos.push(tiempos[indice]);
                        nuevoConcentraciones.push(concentraciones[indice]);
                    }

                    tiempos = nuevoTiempos;
                    concentraciones = nuevoConcentraciones;
                }
            } else {
                for (let i = 0; i < pasos; i++) {
                    let siguienteEstado;

                    if (metodoIntegracion === 'euler') {
                        const k1 = calcularDerivadas(estadoActual);
                        siguienteEstado = estadoActual.map((c, idx) => c + k1[idx] * dt);
                    } else {
                        const k1 = calcularDerivadas(estadoActual);
                        const k2 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * dt * k1[idx]));
                        const k3 = calcularDerivadas(estadoActual.map((c, idx) => c + 0.5 * dt * k2[idx]));
                        const k4 = calcularDerivadas(estadoActual.map((c, idx) => c + dt * k3[idx]));
                        siguienteEstado = estadoActual.map((c, idx) => c + (dt / 6) * (k1[idx] + 2 * k2[idx] + 2 * k3[idx] + k4[idx]));
                    }

                    siguienteEstado = aplicarForzado(siguienteEstado);
                    tiempoActual += dt;

                    tiempos.push(tiempoActual);
                    concentraciones.push(siguienteEstado.slice());
                    estadoActual = siguienteEstado;
                }
            }

            if (infoReactivoLimitante && concentraciones.length > 0) {
                const concentracionFinalLimitante = Math.max(concentraciones[concentraciones.length - 1][infoReactivoLimitante.idx], 0);
                if (infoReactivoLimitante.concentracionInicial > 0) {
                    conversionLimitante = Math.min(
                        100,
                        Math.max(
                            0,
                            (1 - (concentracionFinalLimitante / infoReactivoLimitante.concentracionInicial)) * 100
                        )
                    );
                } else {
                    conversionLimitante = concentracionFinalLimitante === 0 ? 100 : 0;
                }
            }

            if (!razonDetencion) {
                razonDetencion = autoTiempo ? 'Integration completed' : 'User-defined final time'; // === Isolation & limiting-reactant stop rule ===
            }

            const aislamientoLista = Array.from(isolationSet).sort((a, b) => a - b).map(idx => `Especie ${idx + 1}`); // === Catalyst feature ===
            const catalizadorLista = Array.from(catalystSet).sort((a, b) => a - b).map(idx => `Especie ${idx + 1}`); // === Catalyst feature ===
            const aislamientoTexto = aislamientoLista.length > 0 ? aislamientoLista.join(', ') : 'None'; // === Catalyst feature ===
            const catalizadorTexto = catalizadorLista.length > 0 ? catalizadorLista.join(', ') : 'None'; // === Catalyst feature ===
            actualizarChipsEstado({
                infoReactivoLimitante,
                conversionLimitante,
                razonDetencion,
                aislamientoTexto,
                catalizadorTexto
            });

            // Convertir el vector de tiempo de vuelta a la unidad seleccionada por el usuario
            let factorTiempo = 1;
            if (unidadTiempo === 'min') {
                factorTiempo = 60;
            } else if (unidadTiempo === 'h') {
                factorTiempo = 3600;
            }

            tiempos = tiempos.map(tiempo => tiempo / factorTiempo);

            if (autoTiempo) {
                const tiempoFinalConvertido = tiempoFinalSegundos / factorTiempo;
                if (!isNaN(tiempoFinalConvertido) && isFinite(tiempoFinalConvertido)) {
                    document.getElementById('tiempoFinal').value = tiempoFinalConvertido.toFixed(4);
                }
            }

            // Guardar los resultados para el CSV
            resultados = tiempos.map((tiempo, index) => [tiempo, ...concentraciones[index]]);

            datosSimulacion = {
                tiempos: tiempos.slice(),
                concentraciones: concentraciones.map(fila => fila.slice()),
                reactivoBase,
                unidadTiempo,
                unidadConcentracion
            };

            reconstruirGrafica();
        }

        // Funci√≥n para limpiar la gr√°fica y los resultados
        function limpiar() {
            if (grafica) {
                grafica.destroy();  // Destruir la gr√°fica actual
                grafica = null;
            }
            document.getElementById('grafica').getContext('2d').clearRect(0, 0, 400, 400);  // Limpiar el canvas
            resultados = [];  // Borrar los resultados
            datosSimulacion = null;
            const statusElement = document.getElementById('limitingStatus'); // === Isolation & limiting-reactant stop rule ===
            if (statusElement) {
                statusElement.innerHTML = '';
            }
        }

        // Funci√≥n para descargar los resultados como un archivo CSV
        function descargarCSV() {
            if (resultados.length === 0) {
                alert("No hay resultados para descargar.");
                return;
            }

            const notacion = document.getElementById("notacionDecimal").value;

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tiempo;Concentraciones\n";  // Encabezado con punto y coma como separador

            resultados.forEach((fila) => {
                const filaFormateada = fila.map(num => {
                    let strNum = num.toFixed(4); // Convertir a cadena con 4 decimales
                    if (notacion === "coma") {
                        strNum = strNum.replace('.', ','); // Reemplazar punto por coma
                    }
                    return strNum;
                });
                csvContent += filaFormateada.join(";") + "\n";  // Agregar cada fila de datos usando punto y coma
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "resultados_cinetica.csv");
            document.body.appendChild(link);  // Necesario para hacer clic en el enlace
            link.click();  // Descargar el archivo
        }

        const checkboxTiempoAutomatico = document.getElementById('tiempoAutomatico');
        const manejarCambioTiempoAutomatico = (evento) => {
            document.getElementById('tiempoFinal').disabled = evento.target.checked;
        };

        checkboxTiempoAutomatico.addEventListener('change', manejarCambioTiempoAutomatico);

        // Inicializar el formulario
        actualizarFormulario();
        manejarCambioTiempoAutomatico({ target: checkboxTiempoAutomatico });
    </script>
</body>
</html>
